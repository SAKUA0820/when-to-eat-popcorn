<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ãƒãƒƒãƒ—ã‚³ãƒ¼ãƒ³é£Ÿã¹ã©ãæ¤œå‡º</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/starter-sample.css" />
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <script
      src="https://unpkg.com/obniz@3.0.0/obniz.js"
      crossorigin="anonymous"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
  </head>
  <body>
    <!-- <div id="obniz-debug"></div> -->

  <!-- ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã¨ãƒœã‚¿ãƒ³ -->
  <div>
    <p id="status" class="mt-4 ms-4">å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ or ã‚°ãƒ¬ãƒ¼ã®ã‚¨ãƒªã‚¢ã«ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ãã ã•ã„ï¼ˆmp4æ¨å¥¨ï¼‰</p>
    <input id="fileInput" type="file" accept="audio/*,video/*" class="ms-4"><br>
    <button id="analyzeButton" class="btn btn-danger mt-4 ms-4" disabled>ğŸ¿ãƒãƒƒãƒ—ã‚³ãƒ¼ãƒ³ã®é£Ÿã¹ã©ãã‚’æ¢ã™ğŸ¿</button>
    <button id="playButton" class="btn btn-success mt-4 ms-2" disabled>å†ç”Ÿ</button>
    <button id="rewindButton" class="btn btn-secondary mt-4 ms-2" disabled>æœ€åˆã‹ã‚‰</button>
    <button id="topButton" class="btn btn-dark mt-4 ms-2">å‹•ç”»ã‚’å¤‰ãˆã‚‹</button>
  </div>


  <!-- å‹•ç”»ã‚’upã—ãŸã‚‰ã“ã“ã«è¡¨ç¤ºã™ã‚‹ -->
  <div id="video-container" class="mt-4 ms-4" style="visibility: hidden;">
    <video src="" width="1280"></video>
    <canvas id="roudness-graph" width="1280" height="120" style="display: block;"></canvas>
  </div>

  <!-- çµæœè¡¨ç¤º -->
  <div id="result" class="ms-4 mt-4 mb-4" style="visibility: hidden;">
    <p>æ¤œå‡ºçµæœ</p>
    <pre id="output""></pre>
  </div>

  <script>
    const obniz = new Obniz("OBNIZ_ID_HERE");

    const fileInput             = document.getElementById('fileInput');
    const analyzeButton         = document.getElementById('analyzeButton');
    const playButton            = document.getElementById('playButton');
    const rewindButton            = document.getElementById('rewindButton');
    const statusEl              = document.getElementById('status');
    const outputEl              = document.getElementById('output');
    const videoEl               = document.querySelector('video');
    const resutlEl              = document.getElementById('result');
    const videoContainerEl      = document.getElementById('video-container');
    const graphCanvas           = document.getElementById('roudness-graph');

    let decodedBuffer = null;

    let turnTimings = [];   // ãƒˆãƒ¬ãƒ¼ã‚’å›è»¢ã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®é…åˆ—

    // ===== ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆã“ã“ã‚’ã„ã˜ã£ã¦èª¿æ•´ã™ã‚‹ï¼‰ =====
    const FRAME_SEC      = 0.2;   // 0.2ç§’ã”ã¨ã«éŸ³ã®å¤§ãã•ã‚’æ¸¬ã‚‹
    const HOP_SEC        = 0.05;   // 0.05ç§’ãšã¤ãšã‚‰ã—ãªãŒã‚‰æ¸¬ã‚‹
    const SMOOTH_SEC     = 2.0;    // 2ç§’ãã‚‰ã„ã§ãªã‚ã‚‰ã‹ã«ã™ã‚‹
    const RISE_DB_PER_S  = +1.0;   // ã“ã‚Œä»¥ä¸Šã®å‹¢ã„ã§ä¸ŠãŒã£ãŸã‚‰ã€Œã†ã‚‹ã•ããªã‚Šå§‹ã‚ã€
    const FALL_DB_PER_S  = -1.0;   // ã“ã‚Œä»¥ä¸‹ã®å‹¢ã„ã§ä¸‹ãŒã£ãŸã‚‰ã€Œé™ã‹ã«ãªã‚Šå§‹ã‚ã€
    const MIN_GAP_SEC    = 2.5;    // ã‚¤ãƒ™ãƒ³ãƒˆåŒå£«ã®æœ€å°é–“éš”
    const LOUD_PREROLL_SEC    = 1.0;    // éŸ³ãŒå¤§ãããªã£ã¦ã‹ã‚‰ä½•ç§’å¾Œã«å›è»¢ã‚’å§‹ã‚ã‚‹ã‹
    const QUIET_PREROLL_SEC   = 2.0;    // éŸ³ãŒå°ã•ããªã‚‹ä½•ç§’å‰ã«å›è»¢ã‚’å§‹ã‚ã‚‹ã‹

    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã‚“ã ã‚‰è§£æãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹ã«ã™ã‚‹
    fileInput.addEventListener('change', () => {
      const file = fileInput.files?.[0];
      if (file) {
        analyzeButton.disabled = false;
        statusEl.textContent = `${file.name} ãŒé¸æŠã•ã‚Œã¾ã—ãŸã€‚ã‚µã‚¤ã‚º ${(file.size / 1024 / 1024).toFixed(1)} MB`;

        // Blobã§ãƒšãƒ¼ã‚¸ã«å‹•ç”»ã‚’åŸ‹ã‚è¾¼ã‚€
        let URL = window.URL || window.webkitURL;
        videoEl.src = URL.createObjectURL(file);
      } else {
        analyzeButton.disabled = true;
        statusEl.textContent = 'éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã‚“ã§ãã ã•ã„';
      }
      outputEl.textContent = '';
    });

    // ã€Œè§£æã™ã‚‹ã€ã‚’æŠ¼ã—ãŸã¨ã
    analyzeButton.addEventListener('click', async () => {
      const file = fileInput.files?.[0];
      if (!file) return;

      analyzeButton.disabled = true;
      statusEl.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...';

      try {
        const arrayBuffer = await file.arrayBuffer();

        // AudioContext ã®åˆæœŸåŒ–
        const AC = window.AudioContext || window.webkitAudioContext;
        const audioContext = new AC();

        // éŸ³å£°ãƒ‡ã‚³ãƒ¼ãƒ‰
        decodedBuffer = await decodeAudio(arrayBuffer, audioContext);
        const durationSec = decodedBuffer.length / decodedBuffer.sampleRate;
        statusEl.textContent =
          `éŸ³å£°ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¾ã—ãŸ: ${decodedBuffer.sampleRate} Hz, ` +
          `${decodedBuffer.numberOfChannels} ch, é•·ã• ${durationSec.toFixed(1)} ç§’ã€‚è§£æä¸­...`;

        // AudioContextã®ã‚¯ãƒ­ãƒ¼ã‚º
        await audioContext.close();

        // è§£ææœ¬ä½“
        const result = analyzeLoudness(decodedBuffer);

        // éŸ³é‡ã‚°ãƒ©ãƒ•ã®è¡¨ç¤º
        const bars = buildBarsFromSmoothDb(
          result.smoothDb,
          result.dt,
          durationSec,
          graphCanvas.width,
          -60,
          0
        );
        graph.setBars(bars, durationSec, result.events);
        graph.drawAt(0);

        // é£Ÿã¹å§‹ã‚ãƒ»é£Ÿã¹çµ‚ã‚ã‚Šã®çµæœè¡¨ç¤º
        showEvents(result.events);
        turnTimings =  [...result.events];

        statusEl.textContent =
          'è§£æå®Œäº†ï¼';
        analyzeButton.disabled = false;
        playButton.disabled = false;
        rewindButton.disabled = false;
        videoContainerEl.style.visibility = "visible";
        resutlEl.style.visibility = "visible";
      } catch (e) {
        console.error(e);
        statusEl.textContent =
          'ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
        analyzeButton.disabled = false;
      }
    });

    // ã€Œå†ç”Ÿ / ä¸€æ™‚åœæ­¢ã€ã‚’æŠ¼ã—ãŸã¨ã
    playButton.addEventListener('click', async () => {
      if(videoEl.paused){
        // å†ç”Ÿã™ã‚‹
        videoEl.play();
        playButton.textContent = 'ä¸€æ™‚åœæ­¢';
      } else {
        // ä¸€æ™‚åœæ­¢ã™ã‚‹
        videoEl.pause();
        playButton.textContent = 'å†ç”Ÿ';
      }
    });
    
    // ã€Œæœ€åˆã‹ã‚‰ã€ã‚’æŠ¼ã—ãŸæ™‚
    rewindButton.addEventListener('click', async () => {
      // å†ç”Ÿç§’æ•°ã‚’æˆ»ã™
      videoEl.currentTime = 0;
      // éå»ã®eventã®ãƒªã‚¹ãƒˆã‚’haveUsedã‚’æˆ»ã™
      turnTimings.forEach(item => {
        item.haveUsed = false;
      });
    });

    // ã‚°ãƒ©ãƒ•è¡¨ç¤ºç”¨ ã‚¤ãƒ™ãƒ³ãƒˆè¿½åŠ ç­‰
    const graph = createDbGraph(graphCanvas, { dbMin: -60, dbMax: 0 });
    graph.bindCurrentTime(() => videoEl.currentTime);

    videoEl.addEventListener("play", () => graph.start());
    videoEl.addEventListener("pause", () => graph.stop());
    videoEl.addEventListener("ended", () => graph.stop());
    videoEl.addEventListener("seeked", () => graph.drawAt(videoEl.currentTime));

    // obnizæ¥ç¶šæ™‚ã®ã¿å›è»¢
    obniz.onconnect = async () => {
      // GND
      await obniz.io11.output(false);
      // PWM
      let pwm = obniz.getFreePwm();

      // å‹•ç”»ã®å†ç”Ÿæ™‚é–“ãŒå¤‰åŒ–ã—ãŸã¨ã
      videoEl.addEventListener('timeupdate', async() => {
        console.log('å†ç”Ÿæ™‚é–“ãŒå¤‰åŒ–ã—ã¾ã—ãŸ');
        let currentTimeInteger = Math.round(videoEl.currentTime);

        // éŸ³é‡å¤‰åŒ–ãŒãªã„å‹•ç”»ã®å ´åˆã¯return
        if (currentTimeInteger && !turnTimings?.length) {
          statusEl.textContent =
            'å…¨ä½“çš„ã«éŸ³é‡ã«å¤‰åŒ–ãŒãªã„ã‹ã€è§£æãŒå¤±æ•—ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚';
            return;
        }

        // å‹•ç”»ã®æ™‚åˆ»ã¨å›è»¢ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒä¸€è‡´ã—ãŸæ™‚ãƒˆãƒ¬ãƒ¼ã‚’å›è»¢ã•ã›ã‚‹
        turnTimings.forEach(item => {
          if(item.time <= currentTimeInteger && !item.haveUsed){
            console.log(`turn ${item.type}`);
            turnTray(item, pwm);
            item.haveUsed = true;
          }
        });
      });
    }

    // AudioContext.decodeAudioData ã‚’ Promise ã§ãƒ©ãƒƒãƒ—
    function decodeAudio(arrayBuffer, ctx) {
      return new Promise((resolve, reject) => {
        ctx.decodeAudioData(arrayBuffer, resolve, reject);
      });
    }

    // ====== è§£ææœ¬ä½“ =======
    function analyzeLoudness(buffer) {
      const sr = buffer.sampleRate;
      const channels = buffer.numberOfChannels;

      // 1. ãƒ¢ãƒãƒ©ãƒ«åŒ–ï¼ˆè¤‡æ•°chã®å ´åˆã¯å¹³å‡ï¼‰
      let samples;
      if (channels === 1) {
        samples = buffer.getChannelData(0);
      } else {
        samples = averageChannels(buffer);
      }

      // 2. ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã® RMSï¼ˆéŸ³ã®å¤§ãã•ï¼‰ã‚’è¨ˆç®—
      // ãƒ—ãƒ©ã‚¹ãƒã‚¤ãƒŠã‚¤ã‚¹ã§ç›¸æ®ºã—ãªã„ã‚ˆã†ã€2ä¹—å¹³å‡å¹³æ–¹æ ¹ã‚’å‡ºã™
      const frameSize = Math.max(1, Math.round(sr * FRAME_SEC)); //2ä¹—å¹³å‡å¹³æ–¹æ ¹ã‚’å‡ºã™æ™‚ã®ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å¹…
      const hopSize   = Math.max(1, Math.round(sr * HOP_SEC)); //2ä¹—å¹³å‡å¹³æ–¹æ ¹ã‚’å‡ºã™æ™‚ã®ãšã‚‰ã—å¹…
      const rmsArray  = computeFrameRMS(samples, frameSize, hopSize);

      const dt = hopSize / sr; // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ãŸã‚Šã®æ™‚é–“

      // 3. RMS ã‚’ dB ã«å¤‰æ›ï¼ˆæœ€å¤§å€¤ã‚’ 0 dB ã¨ã™ã‚‹ï¼‰
      const dbArray = rmsToDb(rmsArray);
      console.log(rmsArray);

      // 4. æŒ‡æ•°ç§»å‹•å¹³å‡ã§ãªã‚ã‚‰ã‹ã«ã™ã‚‹
      const smoothDb = smoothExponential(dbArray, dt, SMOOTH_SEC);

      // 5. å‹¢ã„ï¼ˆdB/ç§’ï¼‰ã‚’è¨ˆç®—
      const diffDbPerSec = derivative(smoothDb, dt);

      // 6. é™ã‹å´20% / ã†ã‚‹ã•ã„å´80% ã§ã—ãã„å€¤ã‚’æ±ºã‚ã‚‹
      const q20 = percentile(smoothDb, 0.25);
      const q80 = percentile(smoothDb, 0.75);
      const quietThreshold = q20 + 1.0; // å°‘ã—ç·©ã‚ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆ
      const loudThreshold  = q80 - 2.0;

      // 7. ã‚¤ãƒ™ãƒ³ãƒˆæ¤œå‡ºï¼ˆã†ã‚‹ã•ããªã‚Šå§‹ã‚ / é™ã‹ã«ãªã‚Šå§‹ã‚ï¼‰
      const events = detectEvents(
        smoothDb,
        diffDbPerSec,
        dt,
        loudThreshold,
        quietThreshold,
        RISE_DB_PER_S,
        FALL_DB_PER_S,
        MIN_GAP_SEC,
        LOUD_PREROLL_SEC
      );

      return {
        dt,
        dbArray,
        smoothDb,
        diffDbPerSec,
        loudThreshold,
        quietThreshold,
        events,
      };
    }

    // ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ãŸã¡ =====

    // è¤‡æ•°ãƒãƒ£ãƒ³ãƒãƒ«ã‚’å¹³å‡ã—ã¦ãƒ¢ãƒãƒ©ãƒ«ã«ã™ã‚‹
    function averageChannels(buffer) {
      const channels = buffer.numberOfChannels;
      const length = buffer.length;
      const out = new Float32Array(length);

      for (let ch = 0; ch < channels; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < length; i++) {
          out[i] += data[i] / channels;
        }
      }
      return out;
    }

    // ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã® RMS ã‚’è¨ˆç®—
    function computeFrameRMS(samples, frameSize, hopSize) {
      const result = [];
      for (let start = 0; start + frameSize <= samples.length; start += hopSize) {
        let sumSq = 0;
        for (let i = start; i < start + frameSize; i++) {
          const v = samples[i];
          sumSq += v * v;
        }
        const rms = Math.sqrt(sumSq / frameSize);
        result.push(rms);
      }
      return result;
    }

    // RMS é…åˆ—ã‚’ dB ã«å¤‰æ›ï¼ˆæœ€å¤§å€¤ã‚’ 0 dB ã«æ­£è¦åŒ–ï¼‰
    function rmsToDb(rmsArray) {
      const EPS = 1e-12;
      let maxRms = 0;

      // RMSã®æœ€å¤§å€¤ã‚’æ¢ã™
      for (const r of rmsArray) {
        if (r > maxRms) {
          maxRms = r;
        }
      }
      // 0ã‚’é¿ã‘ã‚‹ãŸã‚ã«å°ã•ã„å€¤ã‚’è¶³ã™
      const ref = maxRms + EPS;
      // å„è¦ç´ ã‚’RMSâ†’dBã«å¤‰æ›
      return rmsArray.map(r => 20 * Math.log10((r + EPS) / ref));
    }

    // æŒ‡æ•°ç§»å‹•å¹³å‡ã§ãªã‚ã‚‰ã‹ã«ã™ã‚‹
    function smoothExponential(values, dt, smoothSeconds) {
      const alpha = Math.exp(-dt / smoothSeconds); // 0.0ã€œ1.0
      const out = new Array(values.length);
      out[0] = values[0];
      for (let i = 1; i < values.length; i++) {
        out[i] = alpha * out[i - 1] + (1 - alpha) * values[i];
      }
      return out;
    }

    // 1æ¬¡å¾®åˆ†ï¼ˆéš£ã¨ã®å·®åˆ†ï¼‰ã§ dB/ç§’ ã‚’è¿‘ä¼¼
    function derivative(values, dt) {
      const out = new Array(values.length);
      out[0] = 0;
      for (let i = 1; i < values.length; i++) {
        out[i] = (values[i] - values[i - 1]) / dt;
      }
      return out;
    }

    // å˜ç´”ãªãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«
    function percentile(values, p) {
      const sorted = [...values].sort((a, b) => a - b);
      const idx = (sorted.length - 1) * p;
      const lo = Math.floor(idx);
      const hi = Math.ceil(idx);
      if (lo === hi) return sorted[lo];
      return sorted[lo] + (sorted[hi] - sorted[lo]) * (idx - lo);
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆæ¤œå‡º
    function detectEvents(
      smoothDb,
      diffDbPerSec,
      dt,
      loudThreshold,
      quietThreshold,
      riseThreshold,
      fallThreshold,
      minGapSec,
      prerollSec
    ) {
      const events = [];
      let lastEventTime = -Infinity;

      // æœ€åˆã®çŠ¶æ…‹ï¼ˆé™ã‹ãªå ´é¢ã‹ã€ã†ã‚‹ã•ã„å ´é¢ã‹ï¼‰ã‚’ã–ã£ãã‚Šæ±ºã‚ã‚‹
      const mid = (loudThreshold + quietThreshold) / 2;
      let state = smoothDb[0] < mid ? 'quiet' : 'loud';

      for (let i = 0; i < smoothDb.length; i++) {
        const level = smoothDb[i];
        const slope = diffDbPerSec[i];
        const t = i * dt;

        // ã‚¤ãƒ™ãƒ³ãƒˆåŒå£«ãŒè¿‘ã™ãã‚‹ã¨ãã¯ã‚¹ã‚­ãƒƒãƒ—
        if (t - lastEventTime < minGapSec) continue;

        if (state === 'quiet') {
          // é™ã‹ãªçŠ¶æ…‹ã‹ã‚‰ã€ã†ã‚‹ã•ããªã‚Šå§‹ã‚ãŸã‹ï¼Ÿ
          if (level >= loudThreshold && slope >= riseThreshold) {
            const eventTime = Math.round(Math.max(0, t + LOUD_PREROLL_SEC));
            events.push({ time: eventTime, type: 'LOUD_START', haveUsed: false });
            state = 'loud';
            lastEventTime = t;
          }
        } else {
          // ã†ã‚‹ã•ã„çŠ¶æ…‹ã‹ã‚‰ã€é™ã‹ã«ãªã‚Šå§‹ã‚ãŸã‹ï¼Ÿ
          if (level <= quietThreshold && slope <= fallThreshold) {
            const eventTime = Math.round(Math.max(0, t - QUIET_PREROLL_SEC));
            events.push({ time: eventTime, type: 'QUIET_START', haveUsed: false });
            state = 'quiet';
            lastEventTime = t;
          }
        }
      }

      return events;
    }

    // æ¤œå‡ºçµæœã‚’ç”»é¢ã«è¡¨ç¤º
    function showEvents(events) {
      if (!events.length) {
        outputEl.textContent = 'ã‚¤ãƒ™ãƒ³ãƒˆã¯æ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å°‘ã—ç·©ã‚ã‚‹ã¨å‡ºã¦ãã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚';
        return;
      }

      const lines = events.map((e, i) => {
        const label = e.type === 'LOUD_START'
          ? 'ã†ã‚‹ã•ããªã‚Šå§‹ã‚ é£Ÿã¹ã¦OKï¼'
          : 'é™ã‹ã«ãªã‚Šå§‹ã‚ é£Ÿã¹ã‚‹ã®ã‚¹ãƒˆãƒƒãƒ—ï¼';
        return `  ${e.time} ç§’: ${label}`;
      });

      outputEl.textContent = lines.join('\n');
    }

    // ãƒˆãƒ¬ãƒ¼ã‚’å›ã™
    async function turnTray(event, pwm){
      // å›è»¢æ–¹å‘ã®è¨­å®š
      if(event.type === 'LOUD_START'){
        // Direction
        obniz.io0.output(true);
      } else if(event.type === 'QUIET_START'){
        // Direction
        obniz.io0.output(false);
      }

      pwm.start({io: 1});
      pwm.freq(300);
      pwm.duty(20);

      await obniz.wait(1500);
      await pwm.end();
    }

    // ã‚°ãƒ©ãƒ•è¡¨ç¤ºç”¨ éŸ³å£°é…åˆ—å¤‰æ›
    // å‹•ç”»ã®é•·ã•/ã‚°ãƒ©ãƒ•ã®æ¨ªå¹… ã‚’ã—ãŸã¨ãã®1pxåˆ†ã®Yåº§æ¨™ã®ä½ç½®ã‚’è¨ˆç®—
    function buildBarsFromSmoothDb(smoothDb, dtSec, durationSec, width, dbMin, dbMax) {
      const out = new Float32Array(width);
      const secPerPx = durationSec / width;

      for (let x = 0; x < width; x++) {
        const t0 = x * secPerPx;
        const t1 = (x + 1) * secPerPx;

        const i0 = Math.max(0, Math.floor(t0 / dtSec));
        const i1 = Math.min(smoothDb.length - 1, Math.ceil(t1 / dtSec));

        // 1pxåˆ†ã®ç¯„å›²å†…ã®æœ€å¤§å€¤ã‚’å–ã‚‹(ã†ã‚‹ã•ããªã‚Šå§‹ã‚ã‚’ç›®ç«‹ãŸã›ãŸã„)
        let m = dbMin;
        for (let i = i0; i <= i1; i++) {
          m = Math.max(m, smoothDb[i]);
        }
        if (m > dbMax) m = dbMax;

        out[x] = m;
      }

      return out;
    }

    // ã‚°ãƒ©ãƒ•è¡¨ç¤º
    function createDbGraph(canvas, {
      dbMin = -60,
      dbMax = 0,
      bg = "black",
      line = "red",
      quietBarFill = "rgba(255,255,255,0.35)",
      loudBarFill  = "rgba(120,255,160,0.35)",
    } = {}) {
      const ctx = canvas.getContext("2d");

      // ã†ã‚‹ã•ã„ã¨ã(=ãƒãƒƒãƒ—ã‚³ãƒ¼ãƒ³é£Ÿã¹ã‚‰ã‚Œã‚‹)ã®ã‚°ãƒ©ãƒ•ã®è‰²ã¨ã€ãã†ã§ãªã„ã¨ãã®ã‚°ãƒ©ãƒ•ã®è‰²ã®å®šç¾©
      const Section = {
        QUIET: { key: "QUIET", barFill: quietBarFill },
        LOUD:  { key: "LOUD",  barFill: loudBarFill  },
      };

      let bars = null;
      let durationSec = null;
      let eventsSorted = [];

      let rafId = null;
      let getCurrentTime = null;

      function dbToY(db, H) {
        const clamped = Math.max(dbMin, Math.min(dbMax, db));
        const p = (clamped - dbMin) / (dbMax - dbMin);
        return H * (1 - p);
      }

      function setBars(nextBars, nextDurationSec, nextEvents = []) {
        bars = nextBars;
        durationSec = nextDurationSec;

        eventsSorted = Array.isArray(nextEvents)
          ? [...nextEvents].sort((a, b) => a.time - b.time)
          : [];
      }

      function drawAt(currentTimeSec) {
        const W = canvas.width;
        const H = canvas.height;

        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, W, H);

        if (bars && durationSec && durationSec > 0) {
          const secPerPx = durationSec / W;

          let section = (eventsSorted.length > 0 && eventsSorted[0].type === "QUIET_START")
            ? Section.LOUD
            : Section.QUIET;

          let idx = 0;

          for (let x = 0; x < bars.length; x++) {
            const tMid = (x + 0.5) * secPerPx;

            while (idx < eventsSorted.length && eventsSorted[idx].time <= tMid) {
              if (eventsSorted[idx].type === "LOUD_START") section = Section.LOUD;
              else if (eventsSorted[idx].type === "QUIET_START") section = Section.QUIET;
              idx++;
            }

            const y = dbToY(bars[x], H);
            ctx.fillStyle = section.barFill;
            ctx.fillRect(x, y, 1, H - y);
          }
        } else if (bars) {
          // durationãŒç„¡ã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè‰²ã§æã
          ctx.fillStyle = Section.QUIET.barFill;
          for (let x = 0; x < bars.length; x++) {
            const y = dbToY(bars[x], H);
            ctx.fillRect(x, y, 1, H - y);
          }
        }

        // å†ç”Ÿä½ç½®ã®èµ¤ç·š
        if (durationSec && durationSec > 0) {
          const ratio = currentTimeSec / durationSec;
          const x = ratio * W;

          ctx.strokeStyle = line;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, H);
          ctx.stroke();
        }
      }

      function start() {
        if (rafId) return;
        const loop = () => {
          if (getCurrentTime) drawAt(getCurrentTime());
          rafId = requestAnimationFrame(loop);
        };
        rafId = requestAnimationFrame(loop);
      }

      function stop() {
        if (!rafId) return;
        cancelAnimationFrame(rafId);
        rafId = null;
        if (getCurrentTime) drawAt(getCurrentTime());
      }

      function bindCurrentTime(getter) {
        getCurrentTime = getter;
      }

      return { setBars, drawAt, start, stop, bindCurrentTime };
    }

  </script>

  </body>
</html>
